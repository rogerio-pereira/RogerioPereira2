<?php

namespace Tests\Feature\App\Models;

use App\Events\PurchaseConfirmation;
use App\Mail\EbookDownloadEmail;
use App\Models\Category;
use App\Models\Ebook;
use App\Models\Purchase;
use Illuminate\Support\Facades\Event;

test('purchase belongs to ebook relationship', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
    ]);

    $purchaseEbook = $purchase->ebook;

    $this->assertNotNull($purchaseEbook);
    $this->assertEquals($ebook->id, $purchaseEbook->id);
    $this->assertEquals($ebook->name, $purchaseEbook->name);
});

test('purchase ebook relationship loads ebook correctly', function () {
    $category = Category::factory()->create();
    $ebook1 = Ebook::factory()->create(['category_id' => $category->id]);
    $ebook2 = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase1 = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook1->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
    ]);

    $purchase2 = Purchase::create([
        'name' => 'Jane Doe',
        'email' => 'jane@example.com',
        'phone' => '0987654321',
        'ebook_id' => $ebook2->id,
        'amount' => 39.99,
        'currency' => 'usd',
        'status' => 'completed',
    ]);

    $purchase1Ebook = $purchase1->ebook;
    $purchase2Ebook = $purchase2->ebook;

    $this->assertNotNull($purchase1Ebook);
    $this->assertEquals($ebook1->id, $purchase1Ebook->id);
    $this->assertEquals($ebook1->name, $purchase1Ebook->name);

    $this->assertNotNull($purchase2Ebook);
    $this->assertEquals($ebook2->id, $purchase2Ebook->id);
    $this->assertEquals($ebook2->name, $purchase2Ebook->name);
});

test('purchase observer generates confirmation hash when status is completed on create', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Refresh to get the hash generated by the observer
    $purchase->refresh();

    $this->assertNotNull($purchase->confirmation_hash);
    $this->assertNotEmpty($purchase->confirmation_hash);
});

test('purchase observer generates confirmation hash when status changes to completed', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    $this->assertNull($purchase->confirmation_hash);

    // Update status to completed
    $purchase->update([
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Refresh to get the hash generated by the observer
    $purchase->refresh();

    $this->assertNotNull($purchase->confirmation_hash);
    $this->assertNotEmpty($purchase->confirmation_hash);
});

test('purchase observer does not generate hash when status is not completed', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    $this->assertNull($purchase->confirmation_hash);

    // Update to failed status
    $purchase->update([
        'status' => 'failed',
    ]);

    $purchase->refresh();
    $this->assertNull($purchase->confirmation_hash);
});

test('purchase observer does not regenerate hash if already exists', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $existingHash = 'existing-hash-123';

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
        'confirmation_hash' => $existingHash,
    ]);

    $purchase->refresh();

    // Hash should remain the same, not regenerated
    $this->assertEquals($existingHash, $purchase->confirmation_hash);
});

test('purchase observer generates unique hashes for different purchases', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase1 = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    $purchase2 = Purchase::create([
        'name' => 'Jane Doe',
        'email' => 'jane@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    $purchase1->refresh();
    $purchase2->refresh();

    $this->assertNotNull($purchase1->confirmation_hash);
    $this->assertNotNull($purchase2->confirmation_hash);
    $this->assertNotEquals($purchase1->confirmation_hash, $purchase2->confirmation_hash);
});

test('purchase observer does not generate hash when created with pending status', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    $purchase->refresh();

    $this->assertNull($purchase->confirmation_hash);
});

test('purchase observer does not generate hash when created with failed status', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'failed',
    ]);

    $purchase->refresh();

    $this->assertNull($purchase->confirmation_hash);
});

test('purchase observer does not generate hash when updated but status is not dirty', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    $purchase->refresh();
    $originalHash = $purchase->confirmation_hash;

    // Update a different field, not status
    $purchase->update([
        'name' => 'Jane Doe',
    ]);

    $purchase->refresh();

    // Hash should remain the same since status didn't change
    $this->assertEquals($originalHash, $purchase->confirmation_hash);
});

test('purchase observer does not generate hash when status changes but not to completed', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    $this->assertNull($purchase->confirmation_hash);

    // Update status to failed (not completed)
    $purchase->update([
        'status' => 'failed',
    ]);

    $purchase->refresh();
    $this->assertNull($purchase->confirmation_hash);
});

test('purchase observer does not regenerate hash when status changes to completed but hash already exists', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $existingHash = 'existing-hash-456';

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
        'confirmation_hash' => $existingHash,
    ]);

    // Update status to completed
    $purchase->update([
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    $purchase->refresh();

    // Hash should remain the same, not regenerated
    $this->assertEquals($existingHash, $purchase->confirmation_hash);
});

test('purchase observer does not generate hash when updated from completed to another status', function () {
    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    $purchase->refresh();
    $originalHash = $purchase->confirmation_hash;
    $this->assertNotNull($originalHash);

    // Update status from completed to refunded
    $purchase->update([
        'status' => 'refunded',
    ]);

    $purchase->refresh();

    // Hash should remain the same (observer only generates when changing TO completed, not FROM)
    $this->assertEquals($originalHash, $purchase->confirmation_hash);
});

/*
 * =================================================================================================================
 * Purchase Observer Event Tests
 * =================================================================================================================
 */

test('purchase observer dispatches event when purchase is created with completed status', function () {
    Event::fake([PurchaseConfirmation::class]);

    $category = Category::factory()->create(['name' => 'Automation']);
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'phone' => '1234567890',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    Event::assertDispatched(PurchaseConfirmation::class, function ($event) use ($purchase) {
        return $event->purchase->id === $purchase->id;
    });
});

test('purchase observer dispatches event when status changes to completed', function () {
    Event::fake([PurchaseConfirmation::class]);

    $category = Category::factory()->create(['name' => 'Marketing']);
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'Jane Doe',
        'email' => 'jane@example.com',
        'phone' => '0987654321',
        'ebook_id' => $ebook->id,
        'amount' => 39.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    // No event should be dispatched yet
    Event::assertNotDispatched(PurchaseConfirmation::class);

    // Update status to completed
    $purchase->update([
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    Event::assertDispatched(PurchaseConfirmation::class, function ($event) use ($purchase) {
        return $event->purchase->id === $purchase->id;
    });
});

test('purchase observer does not dispatch event when status is not completed', function () {
    Event::fake([PurchaseConfirmation::class]);

    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'pending',
    ]);

    Event::assertNotDispatched(PurchaseConfirmation::class);

    // Update to failed status
    $purchase->update([
        'status' => 'failed',
    ]);

    Event::assertNotDispatched(PurchaseConfirmation::class);
});

test('ebook download email loads ebook relationship when not loaded in envelope', function () {
    Event::fake();

    $category = Category::factory()->create(['name' => 'Automation']);
    $ebook = Ebook::factory()->create([
        'category_id' => $category->id,
        'name' => 'Test Ebook',
    ]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Unload the ebook relationship
    $purchase->unsetRelation('ebook');

    $email = new EbookDownloadEmail($purchase);
    $envelope = $email->envelope();

    // Should load ebook and use its name
    $this->assertEquals('Your Ebook Download - Test Ebook', $envelope->subject);
});

test('ebook download email loads ebook relationship when not loaded in content', function () {
    Event::fake();

    $category = Category::factory()->create(['name' => 'Marketing']);
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'Jane Doe',
        'email' => 'jane@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 39.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Unload the ebook relationship
    $purchase->unsetRelation('ebook');

    $email = new EbookDownloadEmail($purchase);
    $content = $email->content();

    // Should load ebook and use correct view based on category
    $this->assertEquals('emails.ebook-download.marketing', $content->view);
});

test('ebook download email loads category relationship when ebook loaded but category not', function () {
    Event::fake();

    $category = Category::factory()->create(['name' => 'Software Development']);
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'Bob Smith',
        'email' => 'bob@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 49.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Load ebook but unload category
    $purchase->load('ebook');
    $purchase->ebook->unsetRelation('category');

    $email = new EbookDownloadEmail($purchase);
    $content = $email->content();

    // Should load category and use correct view
    $this->assertEquals('emails.ebook-download.software-development', $content->view);
});

test('ebook download email uses fallback subject when ebook is null', function () {
    Event::fake();

    $category = Category::factory()->create();
    $ebook = Ebook::factory()->create(['category_id' => $category->id]);

    $purchase = Purchase::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'ebook_id' => $ebook->id,
        'amount' => 29.99,
        'currency' => 'usd',
        'status' => 'completed',
        'completed_at' => now(),
    ]);

    // Manually set ebook to null to test fallback
    $purchase->setRelation('ebook', null);

    $email = new EbookDownloadEmail($purchase);
    $envelope = $email->envelope();

    // Should use fallback subject
    $this->assertEquals('Your Ebook Download - Your Ebook', $envelope->subject);
});
